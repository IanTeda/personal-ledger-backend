use personal_ledger_backend::rpc;
use personal_ledger_backend::domain;

use crate::{categories, helpers};


pub type Error = Box<dyn std::error::Error>;
pub type Result<T> = core::result::Result<T, Error>;


#[sqlx::test]
async fn insert_returns_created_category(database_pool: sqlx::SqlitePool) -> Result<()> {
    
    //-- Setup and Fixtures (Arrange)
    let tonic_server = helpers::SpawnTonicServer::init(database_pool).await?;
    let transport_channel = tonic_server.transport_channel();
    let mut tonic_client = helpers::SpawnTonicClient::new(transport_channel);

    let rpc_category = categories::mock_rpc_category();

    let request_message = rpc::CategoryCreateRequest {
        category: Some(rpc_category.clone())
    };

    let request = tonic::Request::new(request_message);

    let response = tonic_client.category().category_create(request).await?;
    let response_message = response.into_inner();

    // println!("{response_message:#?}");

    // Assert that the response contains the expected category
    assert!(response_message.category.is_some());
    let created_category = response_message.category.unwrap();

    // Verify that the created category has the expected fields
    assert_eq!(created_category.code, rpc_category.code);
    assert_eq!(created_category.name, rpc_category.name);
    assert_eq!(created_category.description, rpc_category.description);
    assert_eq!(created_category.url_slug, rpc_category.url_slug);
    assert_eq!(created_category.category_type, rpc_category.category_type);
    assert_eq!(created_category.color, rpc_category.color);
    assert_eq!(created_category.icon, rpc_category.icon);
    assert_eq!(created_category.is_active, rpc_category.is_active);

    // Verify that the ID is generated by the server (not the same as input)
    assert_ne!(created_category.id, rpc_category.id);
    // Verify that the ID is a valid UUID v7 by parsing it
    let parsed_id: domain::RowID = created_category.id.parse()
        .expect("Server should return valid RowID");
    assert_eq!(parsed_id.as_uuid().get_version_num(), 7);

    // Verify that timestamps are set (server should set or preserve them)
    assert!(created_category.created_on.is_some());
    assert!(created_category.updated_on.is_some());

    // Verify that timestamps are reasonable (not in the future, not too old)
    let now = std::time::SystemTime::now();
    let created_timestamp = created_category.created_on.as_ref().unwrap();
    let updated_timestamp = created_category.updated_on.as_ref().unwrap();

    // Timestamps should be within the last minute (allowing for test execution time)
    let one_minute_ago = now.duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() - 60;
    assert!(created_timestamp.seconds >= one_minute_ago as i64);
    assert!(updated_timestamp.seconds >= one_minute_ago as i64);

    // Updated timestamp should be >= created timestamp
    assert!(updated_timestamp.seconds >= created_timestamp.seconds);
    if updated_timestamp.seconds == created_timestamp.seconds {
        assert!(updated_timestamp.nanos >= created_timestamp.nanos);
    }

    Ok(())
}

#[sqlx::test]
async fn create_fails_with_missing_required_fields(database_pool: sqlx::SqlitePool) -> Result<()> {
    let tonic_server = helpers::SpawnTonicServer::init(database_pool).await?;
    let transport_channel = tonic_server.transport_channel();
    let mut tonic_client = helpers::SpawnTonicClient::new(transport_channel);

    // Test missing category field entirely
    let request_message = rpc::CategoryCreateRequest {
        category: None,
    };
    let request = tonic::Request::new(request_message);
    let result = tonic_client.category().category_create(request).await;
    assert!(result.is_err());

    // Test missing code field
    let request_message = rpc::CategoryCreateRequest {
        category: Some(rpc::Category {
            id: "".to_string(),
            code: "".to_string(),
            name: "Test Category".to_string(),
            description: None,
            url_slug: None,
            category_type: rpc::CategoryTypes::Expense as i32,
            color: None,
            icon: None,
            is_active: true,
            created_on: None,
            updated_on: None,
        }),
    };
    let request = tonic::Request::new(request_message);
    let result = tonic_client.category().category_create(request).await;
    assert!(result.is_err());

    // Test missing name field
    let request_message = rpc::CategoryCreateRequest {
        category: Some(rpc::Category {
            id: "".to_string(),
            code: "TEST".to_string(),
            name: "".to_string(),
            description: None,
            url_slug: None,
            category_type: rpc::CategoryTypes::Expense as i32,
            color: None,
            icon: None,
            is_active: true,
            created_on: None,
            updated_on: None,
        }),
    };
    let request = tonic::Request::new(request_message);
    let result = tonic_client.category().category_create(request).await;
    assert!(result.is_err());

    Ok(())
}

#[sqlx::test]
async fn create_fails_with_invalid_category_type(database_pool: sqlx::SqlitePool) -> Result<()> {
    let tonic_server = helpers::SpawnTonicServer::init(database_pool).await?;
    let transport_channel = tonic_server.transport_channel();
    let mut tonic_client = helpers::SpawnTonicClient::new(transport_channel);

    let request_message = rpc::CategoryCreateRequest {
        category: Some(rpc::Category {
            id: "".to_string(),
            code: "INVALID_TYPE".to_string(),
            name: "Invalid Type Category".to_string(),
            description: None,
            url_slug: None,
            category_type: 999, // Invalid category type
            color: None,
            icon: None,
            is_active: true,
            created_on: None,
            updated_on: None,
        }),
    };
    let request = tonic::Request::new(request_message);
    let result = tonic_client.category().category_create(request).await;
    assert!(result.is_err());

    Ok(())
}

#[sqlx::test]
async fn create_fails_with_invalid_color_format(database_pool: sqlx::SqlitePool) -> Result<()> {
    let tonic_server = helpers::SpawnTonicServer::init(database_pool).await?;
    let transport_channel = tonic_server.transport_channel();
    let mut tonic_client = helpers::SpawnTonicClient::new(transport_channel);

    let request_message = rpc::CategoryCreateRequest {
        category: Some(rpc::Category {
            id: "".to_string(),
            code: "INVALID_COLOR".to_string(),
            name: "Invalid Color Category".to_string(),
            description: None,
            url_slug: None,
            category_type: rpc::CategoryTypes::Expense as i32,
            color: Some("invalid-color".to_string()), // Invalid color format
            icon: None,
            is_active: true,
            created_on: None,
            updated_on: None,
        }),
    };
    let request = tonic::Request::new(request_message);
    let result = tonic_client.category().category_create(request).await;
    assert!(result.is_err());

    Ok(())
}

#[sqlx::test]
async fn create_fails_with_duplicate_code(database_pool: sqlx::SqlitePool) -> Result<()> {
    let tonic_server = helpers::SpawnTonicServer::init(database_pool).await?;
    let transport_channel = tonic_server.transport_channel();
    let mut tonic_client = helpers::SpawnTonicClient::new(transport_channel);

    // Create first category
    let rpc_category1 = categories::mock_rpc_category();
    let request_message1 = rpc::CategoryCreateRequest {
        category: Some(rpc_category1.clone())
    };
    let request1 = tonic::Request::new(request_message1);
    let response1 = tonic_client.category().category_create(request1).await?;
    assert!(response1.into_inner().category.is_some());

    // Try to create second category with same code
    let rpc_category2 = rpc::Category {
        id: "".to_string(),
        code: rpc_category1.code.clone(), // Same code
        name: "Different Name".to_string(), // Different name
        description: None,
        url_slug: None,
        category_type: rpc::CategoryTypes::Expense as i32,
        color: None,
        icon: None,
        is_active: true,
        created_on: None,
        updated_on: None,
    };

    let request_message2 = rpc::CategoryCreateRequest {
        category: Some(rpc_category2)
    };
    let request2 = tonic::Request::new(request_message2);
    let result = tonic_client.category().category_create(request2).await;
    assert!(result.is_err()); // Should fail due to duplicate code

    Ok(())
}

#[sqlx::test]
async fn create_fails_with_duplicate_name(database_pool: sqlx::SqlitePool) -> Result<()> {
    let tonic_server = helpers::SpawnTonicServer::init(database_pool).await?;
    let transport_channel = tonic_server.transport_channel();
    let mut tonic_client = helpers::SpawnTonicClient::new(transport_channel);

    // Create first category
    let rpc_category1 = categories::mock_rpc_category();
    let request_message1 = rpc::CategoryCreateRequest {
        category: Some(rpc_category1.clone())
    };
    let request1 = tonic::Request::new(request_message1);
    let response1 = tonic_client.category().category_create(request1).await?;
    assert!(response1.into_inner().category.is_some());

    // Try to create second category with same name
    let rpc_category2 = rpc::Category {
        id: "".to_string(),
        code: "DIFFERENT_CODE".to_string(), // Different code
        name: rpc_category1.name.clone(), // Same name
        description: None,
        url_slug: None,
        category_type: rpc::CategoryTypes::Expense as i32,
        color: None,
        icon: None,
        is_active: true,
        created_on: None,
        updated_on: None,
    };

    let request_message2 = rpc::CategoryCreateRequest {
        category: Some(rpc_category2)
    };
    let request2 = tonic::Request::new(request_message2);
    let result = tonic_client.category().category_create(request2).await;
    assert!(result.is_err()); // Should fail due to duplicate name

    Ok(())
}

#[sqlx::test]
async fn create_succeeds_with_minimal_valid_request(database_pool: sqlx::SqlitePool) -> Result<()> {
    let tonic_server = helpers::SpawnTonicServer::init(database_pool).await?;
    let transport_channel = tonic_server.transport_channel();
    let mut tonic_client = helpers::SpawnTonicClient::new(transport_channel);

    // Create category with only required fields
    let rpc_category = rpc::Category {
        id: "".to_string(),
        code: "MINIMAL".to_string(),
        name: "Minimal Category".to_string(),
        description: None,
        url_slug: None,
        category_type: rpc::CategoryTypes::Expense as i32,
        color: None,
        icon: None,
        is_active: true, // Default value
        created_on: None,
        updated_on: None,
    };

    let request_message = rpc::CategoryCreateRequest {
        category: Some(rpc_category.clone())
    };
    let request = tonic::Request::new(request_message);
    let response = tonic_client.category().category_create(request).await?;
    let response_message = response.into_inner();

    assert!(response_message.category.is_some());
    let created_category = response_message.category.unwrap();

    // Verify required fields are preserved
    assert_eq!(created_category.code, rpc_category.code);
    assert_eq!(created_category.name, rpc_category.name);
    assert_eq!(created_category.category_type, rpc_category.category_type);
    assert_eq!(created_category.is_active, rpc_category.is_active);

    // Verify optional fields are None/empty
    assert!(created_category.description.is_none());
    assert!(created_category.url_slug.is_none());
    assert!(created_category.color.is_none());
    assert!(created_category.icon.is_none());

    // Verify server-generated fields
    assert_ne!(created_category.id, rpc_category.id);
    assert!(created_category.created_on.is_some());
    assert!(created_category.updated_on.is_some());

    Ok(())
}